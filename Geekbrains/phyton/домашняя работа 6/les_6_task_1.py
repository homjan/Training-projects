# 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# b. написать 3 варианта кода (один у вас уже есть);
# проанализировать 3 варианта и выбрать оптимальный;
# c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
# Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# d. написать общий вывод: какой из трёх вариантов лучше и почему.
# Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной
# а проявили творчество, фантазию и создали универсальный код для замера памяти.

# Тесты выполнены на
# 3.6.3 |Anaconda, Inc.| (default, Oct 15 2017, 03:27:45) [MSC v.1900 64 bit (AMD64)]
# win32
import sys
import math

#Cчетчик памяти
def memory_count(lst):
    memory = 0

    for element in lst:
        spam = sys.getsizeof(element)

        if hasattr(element, '__iter__') and not isinstance(element, str):

                spam += memory_count(element)

        memory += spam

    return memory

# Проверяем
# a=5
# b=125.54
# c = 'Hello world!'
# lst = [i for i in range(10)]

# Переменные:  [5, 125.54, 'Hello world!', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]
# Затраты памяти программы:  581


# Задача 2 урока 4

# 2. Написать два алгоритма нахождения i-го по счёту простого числа.
# Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число.
# Проанализировать скорость и сложность алгоритмов.
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
# Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
# Второй — без использования «Решета Эратосфена».

#*******************************************************************************
#Решето Эрастофена

# k=1000
# p = int(2*math.log(k)*k)
# sieve = [i for i in range (p)]
# sieve[1] = 0
#
# for i in range (p):
#
#     if sieve[i]!=0:
#         j= i*2
#
#         while j<p:
#            sieve[j]=0
#            j+=i
#
# result = [i for i in sieve if i!=0]
#
# a= result[k-1]

# Затраты памяти:  509658 при k = 1000
# Затраты памяти:  6581482 при k = 10000
#*****************************************************
#Классический алгоритм

# k=1000
# count = 1
# number = 1
# prime = [2]
#
#
# while count < k:
#    number += 2
#
#    for num in prime:
#          if number % num == 0:
#              break
#          else:
#             count += 1
#             prime.append(number)
#
# b=number

# Затраты памяти:  44260  при k = 1000
# Затраты памяти:  702556 при k = 10000
#*****************************************************

#Вырезаем все переменные в коде и пересчитываем
_variable = []
for i in dir():
    if i[0] != '_' and not hasattr(locals()[i], '__name__'):
        _variable.append(locals()[i])

print('Переменные: ', _variable, '\n')
print('Затраты памяти: ', memory_count(_variable))

#  ВЫВОД: Решето Эрастофена - алгоритм со сложностью n*log(log n) - тратит где-то в 10 раз больше памяти
#  чем обычный алгоритм поиска простых чисел (алгоритм со сложностью n^2). Таким образом в случае избытка свободной памяти и недостатка времени
# следует пользоваться решетом, а в противоположном случае - стандартным методом